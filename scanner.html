<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nexus Real Scanner</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; }
        
        /* Camera Layer */
        video { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        
        /* Debug Overlay Layer (วาดเส้นทับ) */
        canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI */
        .hud { position: absolute; top: 10px; left: 10px; color: #0f0; background: rgba(0,0,0,0.7); padding: 10px; border: 1px solid #0f0; font-size: 12px; pointer-events: none; }
        
        .result-box {
            position: fixed; bottom: 0; left: 0; width: 100%; background: #fff; color: #000;
            padding: 30px; text-align: center; border-radius: 20px 20px 0 0;
            transform: translateY(110%); transition: 0.3s;
        }
        .result-box.show { transform: translateY(0); }
        h1 { margin: 0; word-break: break-all; color: #6366f1; }
    </style>
</head>
<body>

    <video id="video" playsinline></video>
    <canvas id="overlay"></canvas>

    <div class="hud" id="debugInfo">
        SYSTEM: INIT<br>
        THRESHOLD: AUTO<br>
        ANCHOR: SEARCHING...
    </div>

    <div class="result-box" id="resBox">
        <h3 style="margin:0; color:#888;">DECODED DATA</h3>
        <h1 id="resText">...</h1>
        <button onclick="resetScan()" style="margin-top:20px; padding:10px 30px; background:#000; color:#fff; border:none; border-radius:5px; font-weight:bold;">SCAN AGAIN</button>
    </div>

<script>
    const video = document.getElementById('video');
    const cvs = document.getElementById('overlay');
    const ctx = cvs.getContext('2d');
    const debug = document.getElementById('debugInfo');
    
    let isScanning = true;

    // Config
    const SCAN_W = 300; // ความละเอียดในการประมวลผล (ยิ่งน้อยยิ่งเร็ว)
    const SCAN_H = 300;

    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment" } 
            });
            video.srcObject = stream;
            video.play();
            requestAnimationFrame(processFrame);
        } catch(e) { alert("Camera Error: HTTPS Required"); }
    }

    function processFrame() {
        if(!isScanning) return;

        // 1. Setup Canvas ให้ตรงกับหน้าจอ
        cvs.width = window.innerWidth;
        cvs.height = window.innerHeight;

        // สร้าง Virtual Canvas เล็กๆ เพื่อดึงข้อมูล pixel (Performance Optimization)
        const vCvs = document.createElement('canvas');
        vCvs.width = SCAN_W; vCvs.height = SCAN_H;
        const vCtx = vCvs.getContext('2d');
        
        // วาด Video ลง Virtual Canvas
        vCtx.drawImage(video, 0, 0, SCAN_W, SCAN_H);
        const frame = vCtx.getImageData(0, 0, SCAN_W, SCAN_H);
        const data = frame.data;

        // 2. Thresholding & Centroid (หาจุด Anchor สีดำ)
        let sumX = 0, sumY = 0, count = 0;
        
        for(let i=0; i<data.length; i+=4) {
            // Luma (ความสว่าง)
            const luma = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
            
            // ถ้ามืดกว่า 80 (จุดดำ)
            if(luma < 80) {
                const px = (i/4) % SCAN_W;
                const py = Math.floor((i/4) / SCAN_W);
                sumX += px; sumY += py; count++;
            }
        }

        // 3. Logic: ถ้าเจอกลุ่มก้อนสีดำขนาดใหญ่พอสมควร
        if(count > 200 && count < 3000) {
            const cx = sumX / count;
            const cy = sumY / count;

            // แปลงพิกัดกลับมาหน้าจอจริง
            const scaleX = cvs.width / SCAN_W;
            const scaleY = cvs.height / SCAN_H;
            const screenCx = cx * scaleX;
            const screenCy = cy * scaleY;

            // วาดเป้าสีเขียวทับจุด Anchor ที่เจอ
            ctx.strokeStyle = "#0f0"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(screenCx, screenCy, 20, 0, Math.PI*2); ctx.stroke();

            // 4. Find Orientation (North Star)
            // สแกนวงกลมรอบ Anchor รัศมีประมาณ 30% ของจอ (ปรับจูนตามระยะจริง)
            // ในที่นี้เราจะสแกนหาจุดดำที่ระยะห่างออกไป
            
            const scanRadius = 45; // ในหน่วย Virtual 300px (เทียบเท่า 90px ใน Generator 600px)
            let bestAngle = 0;
            let minLuma = 255;
            let foundNorth = false;

            // กวาดเรดาร์รอบตัว 360 องศา
            for(let a=0; a < Math.PI*2; a+=0.1) {
                const tx = cx + scanRadius * Math.cos(a);
                const ty = cy + scanRadius * Math.sin(a);
                
                // อ่านค่าสีที่จุดนั้น
                const idx = (Math.floor(ty) * SCAN_W + Math.floor(tx)) * 4;
                if(idx >= 0 && idx < data.length) {
                    const l = 0.299*data[idx] + 0.587*data[idx+1] + 0.114*data[idx+2];
                    if(l < minLuma) {
                        minLuma = l;
                        bestAngle = a;
                    }
                }
            }

            // ถ้าเจอจุดที่มืดมากๆ ในวงโคจร (North Star)
            if(minLuma < 80) {
                foundNorth = true;
                
                // วาดเส้นชี้ทิศเหนือ
                const northX = (cx + scanRadius * Math.cos(bestAngle)) * scaleX;
                const northY = (cy + scanRadius * Math.sin(bestAngle)) * scaleY;
                
                ctx.beginPath(); ctx.moveTo(screenCx, screenCy); ctx.lineTo(northX, northY);
                ctx.strokeStyle = "red"; ctx.lineWidth = 3; ctx.stroke();

                // 5. READ DATA (Core Logic)
                // เมื่อรู้ Center และ Angle Offset แล้ว เราก็อ่าน Data Rings ได้เลย
                decodeData(vCtx, cx, cy, bestAngle);
            }

            debug.innerHTML = `ANCHOR: LOCKED (${Math.floor(cx)},${Math.floor(cy)})<br>ORIENTATION: ${foundNorth ? (bestAngle*180/Math.PI).toFixed(0)+'°' : 'SEARCHING...'}`;

        } else {
            debug.innerHTML = "ANCHOR: LOST (Try getting closer/White background)";
        }

        requestAnimationFrame(processFrame);
    }

    function decodeData(vCtx, cx, cy, offsetAngle) {
        // Config ต้องตรงกับ Generator
        let radius = 70; // 140/2 (เพราะเราย่อภาพครึ่งนึง 600->300)
        let angle = 0; // เริ่มที่ 0 สัมพัทธ์กับ Offset
        const angleStep = (Math.PI * 2) / 30;
        
        let binaryString = "";
        
        // ลองอ่านสัก 80 บิต (หรือ 10 ตัวอักษร)
        const frame = vCtx.getImageData(0,0,SCAN_W,SCAN_H).data;

        for(let i=0; i<80; i++) {
             if(angle >= Math.PI * 2 - 0.1) {
                angle = 0;
                radius += 15; // 30/2
            }

            // คำนวณพิกัดที่จะเจาะอ่าน (หมุนตาม offsetAngle)
            // x = cx + r * cos(a + offset)
            const readAngle = angle + offsetAngle;
            const tx = Math.floor(cx + radius * Math.cos(readAngle));
            const ty = Math.floor(cy + radius * Math.sin(readAngle));

            // อ่านค่าสี
            const idx = (ty * SCAN_W + tx) * 4;
            let bit = '0';
            
            if(idx >= 0 && idx < frame.length) {
                const l = 0.299*frame[idx] + 0.587*frame[idx+1] + 0.114*frame[idx+2];
                // ถ้าตรงพิกัดนั้นมืด = มีจุด = 1
                if(l < 100) bit = '1';
            }
            binaryString += bit;

            angle += angleStep;
        }

        // Convert Binary to Text
        let text = "";
        for(let i=0; i<binaryString.length; i+=8) {
            const byte = binaryString.substr(i, 8);
            const charCode = parseInt(byte, 2);
            if(charCode > 0 && charCode < 127) {
                text += String.fromCharCode(charCode);
            }
        }

        // Check Valid Text (กรองขยะ)
        if(text.length > 2 && /^[a-zA-Z0-9\s]+$/.test(text.substring(0,3))) {
            showResult(text);
        }
    }

    function showResult(text) {
        isScanning = false;
        if(navigator.vibrate) navigator.vibrate(200);
        document.getElementById('resText').innerText = text;
        document.getElementById('resBox').classList.add('show');
    }

    function resetScan() {
        document.getElementById('resBox').classList.remove('show');
        isScanning = true;
        requestAnimationFrame(processFrame);
    }

    init();
</script>
</body>
</html>
